'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PropTypes = require('prop-types');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var version = "1.5.4";
var errorMessages = {
  MANDATORY_INITIALIZATION_MISSING: {
    message: "Missing urlEndpoint during SDK initialization",
    help: ""
  },
  INVALID_TRANSFORMATION_POSITION: {
    message: "Invalid transformationPosition parameter",
    help: ""
  },
  PRIVATE_KEY_CLIENT_SIDE: {
    message: "privateKey should not be passed on the client side",
    help: ""
  },
  MISSING_UPLOAD_DATA: {
    message: "Missing data for upload",
    help: ""
  },
  MISSING_UPLOAD_FILE_PARAMETER: {
    message: "Missing file parameter for upload",
    help: ""
  },
  MISSING_UPLOAD_FILENAME_PARAMETER: {
    message: "Missing fileName parameter for upload",
    help: ""
  },
  MISSING_AUTHENTICATION_ENDPOINT: {
    message: "Missing authentication endpoint for upload",
    help: ""
  },
  MISSING_PUBLIC_KEY: {
    message: "Missing public key for upload",
    help: ""
  },
  AUTH_ENDPOINT_TIMEOUT: {
    message: "The authenticationEndpoint you provided timed out in 60 seconds",
    help: ""
  },
  AUTH_ENDPOINT_NETWORK_ERROR: {
    message: "Request to authenticationEndpoint failed due to network error",
    help: ""
  },
  AUTH_INVALID_RESPONSE: {
    message: "Invalid response from authenticationEndpoint. The SDK expects a JSON response with three fields i.e. signature, token and expire.",
    help: ""
  },
  UPLOAD_ENDPOINT_NETWORK_ERROR: {
    message: "Request to ImageKit upload endpoint failed due to network error",
    help: ""
  },
  INVALID_UPLOAD_OPTIONS: {
    message: "Invalid uploadOptions parameter",
    help: ""
  }
};

function respond(isError, response, callback) {
  if (typeof callback == "function") {
    if (isError) {
      callback(response, null);
    } else {
      callback(null, response);
    }
  }
}

function getResponseHeaderMap(xhr) {
  var headers = {};
  var responseHeaders = xhr.getAllResponseHeaders();

  if (Object.keys(responseHeaders).length) {
    responseHeaders.trim().split(/[\r\n]+/).map(function (value) {
      return value.split(/: /);
    }).forEach(function (keyValue) {
      headers[keyValue[0].trim()] = keyValue[1].trim();
    });
  }

  return headers;
}

var addResponseHeadersAndBody = function addResponseHeadersAndBody(body, xhr) {
  var response = _objectSpread2({}, body);

  var responseMetadata = {
    statusCode: xhr.status,
    headers: getResponseHeaderMap(xhr)
  };
  Object.defineProperty(response, "$ResponseMetadata", {
    value: responseMetadata,
    enumerable: false,
    writable: false
  });
  return response;
};

var request = function request(uploadFileXHR, formData, options, callback) {
  generateSignatureToken(options.authenticationEndpoint).then(function (signaturObj) {
    formData.append("signature", signaturObj.signature);
    formData.append("expire", String(signaturObj.expire));
    formData.append("token", signaturObj.token);
    uploadFile(uploadFileXHR, formData).then(function (result) {
      return respond(false, result, callback);
    }, function (ex) {
      return respond(true, ex, callback);
    });
  }, function (ex) {
    return respond(true, ex, callback);
  });
};

var generateSignatureToken = function generateSignatureToken(authenticationEndpoint) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.timeout = 60000;
    var urlObj = new URL(authenticationEndpoint);
    urlObj.searchParams.set("t", Math.random().toString());
    xhr.open('GET', urlObj.toString());

    xhr.ontimeout = function (e) {
      return reject(errorMessages.AUTH_ENDPOINT_TIMEOUT);
    };

    xhr.onerror = function () {
      return reject(errorMessages.AUTH_ENDPOINT_NETWORK_ERROR);
    };

    xhr.onload = function () {
      if (xhr.status === 200) {
        try {
          var body = JSON.parse(xhr.responseText);
          var obj = {
            signature: body.signature,
            expire: body.expire,
            token: body.token
          };

          if (!obj.signature || !obj.expire || !obj.token) {
            return reject(errorMessages.AUTH_INVALID_RESPONSE);
          }

          return resolve(obj);
        } catch (ex) {
          return reject(errorMessages.AUTH_INVALID_RESPONSE);
        }
      } else {
        return reject(errorMessages.AUTH_INVALID_RESPONSE);
      }
    };

    xhr.send();
  });
};

var uploadFile = function uploadFile(uploadFileXHR, formData) {
  return new Promise(function (resolve, reject) {
    uploadFileXHR.open('POST', 'https://upload.imagekit.io/api/v1/files/upload');

    uploadFileXHR.onerror = function (e) {
      return reject(errorMessages.UPLOAD_ENDPOINT_NETWORK_ERROR);
    };

    uploadFileXHR.onload = function () {
      if (uploadFileXHR.status === 200) {
        try {
          var body = JSON.parse(uploadFileXHR.responseText);
          var uploadResponse = addResponseHeadersAndBody(body, uploadFileXHR);
          return resolve(uploadResponse);
        } catch (ex) {
          return reject(ex);
        }
      } else {
        try {
          var body = JSON.parse(uploadFileXHR.responseText);
          var uploadError = addResponseHeadersAndBody(body, uploadFileXHR);
          return reject(uploadError);
        } catch (ex) {
          return reject(ex);
        }
      }
    };

    uploadFileXHR.send(formData);
  });
};

var upload = function upload(xhr, uploadOptions, options, callback) {
  if (!uploadOptions.file) {
    respond(true, errorMessages.MISSING_UPLOAD_FILE_PARAMETER, callback);
    return;
  }

  if (!uploadOptions.fileName) {
    respond(true, errorMessages.MISSING_UPLOAD_FILENAME_PARAMETER, callback);
    return;
  }

  if (!options.authenticationEndpoint) {
    respond(true, errorMessages.MISSING_AUTHENTICATION_ENDPOINT, callback);
    return;
  }

  if (!options.publicKey) {
    respond(true, errorMessages.MISSING_PUBLIC_KEY, callback);
    return;
  }

  var formData = new FormData();
  var key;

  for (key in uploadOptions) {
    if (key) {
      if (key === "file" && typeof uploadOptions.file != "string") {
        formData.append('file', uploadOptions.file, String(uploadOptions.fileName));
      } else if (key === "tags" && Array.isArray(uploadOptions.tags)) {
        formData.append('tags', uploadOptions.tags.join(","));
      } else if (key === "responseFields" && Array.isArray(uploadOptions.responseFields)) {
        formData.append('responseFields', uploadOptions.responseFields.join(","));
      } else if (key === "extensions" && Array.isArray(uploadOptions.extensions)) {
        formData.append('extensions', JSON.stringify(uploadOptions.extensions));
      } else if (key === "customMetadata" && _typeof(uploadOptions.customMetadata) === "object" && !Array.isArray(uploadOptions.customMetadata) && uploadOptions.customMetadata !== null) {
        formData.append('customMetadata', JSON.stringify(uploadOptions.customMetadata));
      } else if (uploadOptions[key] !== undefined) {
        formData.append(key, String(uploadOptions[key]));
      }
    }
  }

  formData.append("publicKey", options.publicKey);
  request(xhr, formData, _objectSpread2(_objectSpread2({}, options), {}, {
    authenticationEndpoint: options.authenticationEndpoint
  }), callback);
};

var supportedTransforms = {
  width: "w",
  height: "h",
  aspectRatio: "ar",
  quality: "q",
  crop: "c",
  cropMode: "cm",
  focus: "fo",
  x: "x",
  y: "y",
  format: "f",
  radius: "r",
  background: "bg",
  border: "b",
  rotation: "rt",
  rotate: "rt",
  blur: "bl",
  named: "n",
  overlayImage: "oi",
  overlayImageAspectRatio: "oiar",
  overlayImageBackground: "oibg",
  overlayImageBorder: "oib",
  overlayImageDPR: "oidpr",
  overlayImageQuality: "oiq",
  overlayImageCropping: "oic",
  overlayImageTrim: "oit",
  overlayX: "ox",
  overlayY: "oy",
  overlayFocus: "ofo",
  overlayHeight: "oh",
  overlayWidth: "ow",
  overlayText: "ot",
  overlayTextFontSize: "ots",
  overlayTextFontFamily: "otf",
  overlayTextColor: "otc",
  overlayTextTransparency: "oa",
  overlayAlpha: "oa",
  overlayTextTypography: "ott",
  overlayBackground: "obg",
  overlayTextEncoded: "ote",
  overlayTextWidth: "otw",
  overlayTextBackground: "otbg",
  overlayTextPadding: "otp",
  overlayTextInnerAlignment: "otia",
  overlayRadius: "or",
  progressive: "pr",
  lossless: "lo",
  trim: "t",
  metadata: "md",
  colorProfile: "cp",
  defaultImage: "di",
  dpr: "dpr",
  effectSharpen: "e-sharpen",
  effectUSM: "e-usm",
  effectContrast: "e-contrast",
  effectGray: "e-grayscale",
  original: "orig",
  raw: "raw"
};
var DEFAULT_TRANSFORMATION_POSITION = "path";
var QUERY_TRANSFORMATION_POSITION = "query";
var VALID_TRANSFORMATION_POSITIONS = [DEFAULT_TRANSFORMATION_POSITION, QUERY_TRANSFORMATION_POSITION];
var CHAIN_TRANSFORM_DELIMITER = ":";
var TRANSFORM_DELIMITER = ",";
var TRANSFORM_KEY_VALUE_DELIMITER = "-";
var transformationUtils = {
  getDefault: function getDefault() {
    return DEFAULT_TRANSFORMATION_POSITION;
  },
  addAsQueryParameter: function addAsQueryParameter(options) {
    return options.transformationPosition === QUERY_TRANSFORMATION_POSITION;
  },
  validParameters: function validParameters(options) {
    if (typeof options.transformationPosition == "undefined") return false;
    return VALID_TRANSFORMATION_POSITIONS.indexOf(options.transformationPosition) != -1;
  },
  getTransformKey: function getTransformKey(transform) {
    if (!transform) {
      return "";
    }

    return supportedTransforms[transform] || supportedTransforms[transform.toLowerCase()] || "";
  },
  getChainTransformDelimiter: function getChainTransformDelimiter() {
    return CHAIN_TRANSFORM_DELIMITER;
  },
  getTransformDelimiter: function getTransformDelimiter() {
    return TRANSFORM_DELIMITER;
  },
  getTransformKeyValueDelimiter: function getTransformKeyValueDelimiter() {
    return TRANSFORM_KEY_VALUE_DELIMITER;
  }
};
var TRANSFORMATION_PARAMETER = "tr";

function removeTrailingSlash(str) {
  if (typeof str == "string" && str[str.length - 1] == "/") {
    str = str.substring(0, str.length - 1);
  }

  return str;
}

function removeLeadingSlash(str) {
  if (typeof str == "string" && str[0] == "/") {
    str = str.slice(1);
  }

  return str;
}

function pathJoin(parts, sep) {
  var separator = sep || "/";
  var replace = new RegExp(separator + "{1,}", "g");
  return parts.join(separator).replace(replace, separator);
}

var buildURL = function buildURL(opts) {
  if (!opts.path && !opts.src) {
    return "";
  }

  var urlObj, isSrcParameterUsedForURL, urlEndpointPattern;

  try {
    if (opts.path) {
      urlEndpointPattern = new URL(opts.urlEndpoint).pathname;
      urlObj = new URL(pathJoin([opts.urlEndpoint.replace(urlEndpointPattern, ""), opts.path]));
    } else {
      urlObj = new URL(opts.src);
      isSrcParameterUsedForURL = true;
    }
  } catch (e) {
    console.error(e);
    return "";
  }

  for (var i in opts.queryParameters) {
    urlObj.searchParams.append(i, String(opts.queryParameters[i]));
  }

  var transformationString = constructTransformationString(opts.transformation);

  if (transformationString && transformationString.length) {
    if (transformationUtils.addAsQueryParameter(opts) || isSrcParameterUsedForURL) {
      urlObj.searchParams.append(TRANSFORMATION_PARAMETER, transformationString);
    } else {
      urlObj.pathname = pathJoin([TRANSFORMATION_PARAMETER + transformationUtils.getChainTransformDelimiter() + transformationString, urlObj.pathname]);
    }
  }

  if (urlEndpointPattern) {
    urlObj.pathname = pathJoin([urlEndpointPattern, urlObj.pathname]);
  } else {
    urlObj.pathname = pathJoin([urlObj.pathname]);
  }

  return urlObj.href;
};

function constructTransformationString(transformation) {
  if (!Array.isArray(transformation)) {
    return "";
  }

  var parsedTransforms = [];

  for (var i = 0, l = transformation.length; i < l; i++) {
    var parsedTransformStep = [];

    for (var key in transformation[i]) {
      var transformKey = transformationUtils.getTransformKey(key);

      if (!transformKey) {
        transformKey = key;
      }

      if (transformation[i][key] === "-") {
        parsedTransformStep.push(transformKey);
      } else if (key === "raw") {
        parsedTransformStep.push(transformation[i][key]);
      } else {
        var value = transformation[i][key];

        if (transformKey === "oi" || transformKey === "di") {
          value = removeTrailingSlash(removeLeadingSlash(value || ""));
          value = value.replace(/\//g, "@@");
        }

        parsedTransformStep.push([transformKey, value].join(transformationUtils.getTransformKeyValueDelimiter()));
      }
    }

    parsedTransforms.push(parsedTransformStep.join(transformationUtils.getTransformDelimiter()));
  }

  return parsedTransforms.join(transformationUtils.getChainTransformDelimiter());
}

var url = function url(urlOpts, defaultOptions) {
  return buildURL(_objectSpread2(_objectSpread2({}, defaultOptions), urlOpts));
};

function mandatoryParametersAvailable(options) {
  return options.urlEndpoint;
}

var promisify = function promisify(thisContext, fn) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === fn.length && typeof args[args.length - 1] !== "undefined") {
      if (typeof args[args.length - 1] !== "function") {
        throw new Error("Callback must be a function.");
      }

      fn.call.apply(fn, [thisContext].concat(args));
    } else {
      return new Promise(function (resolve, reject) {
        var callback = function callback(err) {
          if (err) {
            return reject(err);
          } else {
            for (var _len2 = arguments.length, results = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              results[_key2 - 1] = arguments[_key2];
            }

            resolve(results.length > 1 ? results : results[0]);
          }
        };

        args.pop();
        args.push(callback);
        fn.call.apply(fn, [thisContext].concat(args));
      });
    }
  };
};

var ImageKit = function () {
  function ImageKit(opts) {
    _classCallCheck(this, ImageKit);

    _defineProperty(this, "options", {
      sdkVersion: "javascript-".concat(version),
      publicKey: "",
      urlEndpoint: "",
      transformationPosition: transformationUtils.getDefault()
    });

    this.options = _objectSpread2(_objectSpread2({}, this.options), opts || {});

    if (!mandatoryParametersAvailable(this.options)) {
      throw errorMessages.MANDATORY_INITIALIZATION_MISSING;
    }

    if (!transformationUtils.validParameters(this.options)) {
      throw errorMessages.INVALID_TRANSFORMATION_POSITION;
    }
  }

  _createClass(ImageKit, [{
    key: "url",
    value: function url$1(urlOptions) {
      return url(urlOptions, this.options);
    }
  }, {
    key: "upload",
    value: function upload$1(uploadOptions, callbackOrOptions, options) {
      var callback;

      if (typeof callbackOrOptions === 'function') {
        callback = callbackOrOptions;
      } else {
        options = callbackOrOptions || {};
      }

      if (!uploadOptions || _typeof(uploadOptions) !== "object") {
        return respond(true, errorMessages.INVALID_UPLOAD_OPTIONS, callback);
      }

      var mergedOptions = _objectSpread2(_objectSpread2({}, this.options), options);

      var _ref = uploadOptions || {},
          userProvidedXHR = _ref.xhr;

      delete uploadOptions.xhr;
      var xhr = userProvidedXHR || new XMLHttpRequest();
      return promisify(this, upload)(xhr, uploadOptions, mergedOptions, callback);
    }
  }]);

  return ImageKit;
}();

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ImageKitContextType = /*#__PURE__*/React.createContext(null);

var ImageKitComponent = /*#__PURE__*/function (_PureComponent) {
  _inherits(ImageKitComponent, _PureComponent);

  var _super = _createSuper(ImageKitComponent);

  function ImageKitComponent(props, context) {
    var _this;

    _classCallCheck$1(this, ImageKitComponent);

    _this = _super.call(this, props, context);
    _this.getContext = _this.getContext.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass$1(ImageKitComponent, [{
    key: "getContext",
    value: function getContext() {
      return this.context || {};
    }
  }, {
    key: "getIKClient",
    value: function getIKClient() {
      var contextOptions = this.getContext();

      if (contextOptions.ikClient) {
        return contextOptions.ikClient;
      }

      var urlEndpoint = this.props.urlEndpoint;
      urlEndpoint = urlEndpoint || contextOptions.urlEndpoint;

      if (!urlEndpoint || urlEndpoint.trim() === "") {
        throw new Error("Missing urlEndpoint during initialization");
      }

      var ikClient = new ImageKit({
        urlEndpoint: urlEndpoint,
        // @ts-ignore
        sdkVersion: ""
      });
      return ikClient;
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return ImageKitComponent;
}(React.PureComponent);

ImageKitComponent.contextType = ImageKitContextType;

var Props = {
  loading: PropTypes__default['default'].oneOf(['lazy']),
  lqip: PropTypes__default['default'].shape({
    active: PropTypes__default['default'].bool,
    quality: PropTypes__default['default'].number,
    threshold: PropTypes__default['default'].number,
    blur: PropTypes__default['default'].number,
    raw: PropTypes__default['default'].string
  }),
  path: PropTypes__default['default'].string,
  src: PropTypes__default['default'].string,
  queryParameters: PropTypes__default['default'].objectOf(PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].number]).isRequired),
  transformation: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object.isRequired),
  transformationPosition: PropTypes__default['default'].oneOf(['path', 'query'])
};

var Props$1 = {
  fileName: PropTypes__default['default'].string,
  tags: PropTypes__default['default'].arrayOf(PropTypes__default['default'].string.isRequired),
  useUniqueFileName: PropTypes__default['default'].bool,
  responseFields: PropTypes__default['default'].array,
  isPrivateFile: PropTypes__default['default'].bool,
  folder: PropTypes__default['default'].string,
  customCoordinates: PropTypes__default['default'].string,
  extensions: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object.isRequired),
  webhookUrl: PropTypes__default['default'].string,
  overwriteFile: PropTypes__default['default'].bool,
  overwriteAITags: PropTypes__default['default'].bool,
  overwriteTags: PropTypes__default['default'].bool,
  overwriteCustomMetadata: PropTypes__default['default'].bool,
  customMetadata: PropTypes__default['default'].any,
  onError: PropTypes__default['default'].func,
  onSuccess: PropTypes__default['default'].func,
  onUploadStart: PropTypes__default['default'].func,
  onUploadProgress: PropTypes__default['default'].func,
  inputRef: PropTypes__default['default'].object,
  validateFile: PropTypes__default['default'].func
};

var Props$2 = {
  publicKey: PropTypes__default['default'].string,
  urlEndpoint: PropTypes__default['default'].string,
  authenticationEndpoint: PropTypes__default['default'].string
};
var IKContextCombinedProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, Props$2), Props), Props$1), Props$1), {}, {
  ikClient: PropTypes__default['default'].instanceOf(ImageKit)
});

/**
 * Provides a container for ImageKit components. Any option set in IKContext will be passed to the children.
 *
 * @example
 *<IKContext  publicKey="<public key>" urlEndpoint="url link">
 *    <!-- other tags -->
 *    <Image src={link}/>
 *</IKContext>
 */

var IKContext = /*#__PURE__*/function (_ImageKitComponent) {
  _inherits(IKContext, _ImageKitComponent);

  var _super = _createSuper(IKContext);

  function IKContext() {
    _classCallCheck$1(this, IKContext);

    return _super.apply(this, arguments);
  }

  _createClass$1(IKContext, [{
    key: "extractContextOptions",
    value: function extractContextOptions(mergedOptions) {
      var result = {};
      var propKeys = Object.keys(IKContextCombinedProps);

      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var value = mergedOptions[key];

        if (value) {
          result[key] = value;
        }
      }

      return result;
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;

      var mergedOptions = _objectSpread2$1(_objectSpread2$1({}, this.getContext()), this.props);

      var contextOptions = this.extractContextOptions(mergedOptions);

      if (contextOptions.urlEndpoint && contextOptions.urlEndpoint.trim() !== "") {
        contextOptions.ikClient = new ImageKit({
          urlEndpoint: contextOptions.urlEndpoint,
          // @ts-ignore
          sdkVersion: ""
        });
      }

      return /*#__PURE__*/React__default['default'].createElement(ImageKitContextType.Provider, {
        value: contextOptions
      }, children);
    }
  }]);

  return IKContext;
}(ImageKitComponent);

IKContext.propTypes = IKContextCombinedProps;

var COMBINED_IMAGE_PROP_TYPES = _objectSpread2$1(_objectSpread2$1({}, Props$2), Props);

var fetchEffectiveConnection = function fetchEffectiveConnection() {
  try {
    return navigator.connection.effectiveType;
  } catch (ex) {
    return "4g";
  }
};
var areObjectsDifferent = function areObjectsDifferent(prevProps, newProps, propsAffectingURL) {
  for (var index = 0; index < propsAffectingURL.length; index++) {
    if (prevProps[propsAffectingURL[index]] !== newProps[propsAffectingURL[index]]) {
      return true;
    }
  }

  return false;
};
var getSrc = function getSrc(_ref, ikClient, contextOptions) {
  var urlEndpoint = _ref.urlEndpoint,
      lqip = _ref.lqip,
      src = _ref.src,
      path = _ref.path,
      transformation = _ref.transformation,
      transformationPosition = _ref.transformationPosition,
      queryParameters = _ref.queryParameters;
  // @ts-ignore
  var options = {
    urlEndpoint: urlEndpoint || contextOptions.urlEndpoint,
    src: src || contextOptions.src || undefined,
    path: path || contextOptions.path || undefined,
    transformation: transformation || contextOptions.transformation,
    transformationPosition: transformationPosition || contextOptions.transformationPosition || undefined,
    queryParameters: queryParameters || contextOptions.queryParameters || {}
  };
  var result = {
    originalSrc: ikClient.url(options)
  };

  if (lqip && lqip.active) {
    var quality = Math.round(lqip.quality || lqip.threshold || 20);
    var blur = Math.round(lqip.blur || 6);
    var newTransformation = options.transformation ? _toConsumableArray(options.transformation) : [];

    if (lqip.raw && typeof lqip.raw === "string" && lqip.raw.trim() != "") {
      newTransformation.push({
        raw: lqip.raw.trim()
      });
    } else {
      newTransformation.push({
        quality: String(quality),
        blur: String(blur)
      });
    }

    result.lqipSrc = ikClient.url(_objectSpread2$1(_objectSpread2$1({}, options), {}, {
      transformation: newTransformation
    }));
  }

  return result;
};
var getIKElementsUrl = function getIKElementsUrl(_ref2, _ref3) {
  var _ref2$lqip = _ref2.lqip,
      lqip = _ref2$lqip === void 0 ? null : _ref2$lqip,
      loading = _ref2.loading;
  var intersected = _ref3.intersected,
      originalSrcLoaded = _ref3.originalSrcLoaded,
      originalSrc = _ref3.originalSrc,
      lqipSrc = _ref3.lqipSrc;

  /*
    No lazy loading no lqip
      src=originalImage
    No lazy loading lqip
      src=lqip
      src=originalImage (when loaded)
    lazy loading and no lqip
      src=''
      onIntersect:
      src=originalImage
    lazy loading and lqip
      src=lqip
      onIntersect:
      src=originalImage (when loaded)
  */
  var isLqipActive = function isLqipActive(lqip) {
    return lqip && lqip.active;
  };

  if (loading !== "lazy" && !isLqipActive(lqip)) {
    return originalSrc;
  } else if (loading !== "lazy" && isLqipActive(lqip)) {
    if (originalSrcLoaded) {
      return originalSrc;
    } else {
      return lqipSrc;
    }
  } else if (loading === "lazy" && !isLqipActive(lqip)) {
    if (intersected) {
      return originalSrc;
    } else {
      return "";
    }
  } else {
    //  if (loading === "lazy" && isLqipActive(lqip))
    if (intersected && originalSrcLoaded) {
      return originalSrc;
    } else {
      return lqipSrc;
    }
  }
};

var propsAffectingURL = ["urlEndpoint", "path", "src", "transformation", "transformationPosition", "queryParameters"];

var IKImage = /*#__PURE__*/function (_ImageKitComponent) {
  _inherits(IKImage, _ImageKitComponent);

  var _super = _createSuper(IKImage);

  function IKImage(props, context) {
    var _this;

    _classCallCheck$1(this, IKImage);

    _this = _super.call(this, props, context);
    _this.imageRef = /*#__PURE__*/React__default['default'].createRef();

    var _getSrc = getSrc(_this.props, _this.getIKClient(), _this.getContext()),
        originalSrc = _getSrc.originalSrc,
        lqipSrc = _getSrc.lqipSrc;

    _this.state = {
      currentUrl: undefined,
      originalSrc: originalSrc,
      lqipSrc: lqipSrc,
      originalSrcLoaded: false,
      intersected: false,
      contextOptions: {}
    };
    return _this;
  }

  _createClass$1(IKImage, [{
    key: "updateImageUrl",
    value: function updateImageUrl() {
      var url = getIKElementsUrl(this.props, this.state);
      this.setState({
        currentUrl: url
      });
    }
  }, {
    key: "triggerOriginalImageLoad",
    value: function triggerOriginalImageLoad() {
      var _this2 = this;

      var img = new Image();

      img.onload = function () {
        _this2.setState({
          originalSrcLoaded: true
        }, function () {
          _this2.updateImageUrl();
        });
      };

      img.src = this.state.originalSrc;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this3 = this;

      this.updateImageUrl();
      this.setState({
        contextOptions: this.getContext()
      });
      var image = this.imageRef.current;
      var _this$props = this.props,
          lqip = _this$props.lqip,
          loading = _this$props.loading;

      if (window && 'IntersectionObserver' in window && loading === "lazy") {
        var connectionType = fetchEffectiveConnection(); // Values based on native lazy loading in Chrome - https://web.dev/native-lazy-loading/#improved-data-savings-and-distance-from-viewport-thresholds

        var rootMargin = "1250px";
        if (connectionType !== "4g") rootMargin = "2500px";
        var imageObserver = new IntersectionObserver(function (entries) {
          var el = entries[0];

          if (el && el.isIntersecting) {
            _this3.setState({
              intersected: true
            }, function () {
              if (lqip && lqip.active) _this3.triggerOriginalImageLoad();
              imageObserver.disconnect();

              _this3.updateImageUrl();
            });
          }
        }, {
          rootMargin: "".concat(rootMargin, " 0px ").concat(rootMargin, " 0px")
        });
        imageObserver.observe(image);
        this.setState({
          observe: imageObserver
        });
      } else {
        // Load original image right away
        this.setState({
          intersected: true
        }, function () {
          if (lqip && lqip.active) _this3.triggerOriginalImageLoad();

          _this3.updateImageUrl();
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var observe = this.state.observe;
      if (observe) observe.disconnect();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this4 = this;

      var contextOptions = this.getContext();

      if (areObjectsDifferent(prevProps, this.props, propsAffectingURL) || areObjectsDifferent(prevState.contextOptions, contextOptions, propsAffectingURL)) {
        var _getSrc2 = getSrc(this.props, this.getIKClient(), this.getContext()),
            originalSrc = _getSrc2.originalSrc,
            lqipSrc = _getSrc2.lqipSrc;

        this.setState({
          originalSrc: originalSrc,
          lqipSrc: lqipSrc
        }, function () {
          _this4.updateImageUrl();

          _this4.setState({
            contextOptions: _this4.getContext()
          });
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var currentUrl = this.state.currentUrl;

      var _this$props2 = this.props,
          urlEndpoint = _this$props2.urlEndpoint,
          loading = _this$props2.loading,
          lqip = _this$props2.lqip,
          path = _this$props2.path,
          src = _this$props2.src,
          transformation = _this$props2.transformation,
          transformationPosition = _this$props2.transformationPosition,
          queryParameters = _this$props2.queryParameters,
          restProps = _objectWithoutProperties(_this$props2, ["urlEndpoint", "loading", "lqip", "path", "src", "transformation", "transformationPosition", "queryParameters"]);

      return /*#__PURE__*/React__default['default'].createElement("img", _extends({
        alt: this.props.alt || "",
        src: currentUrl,
        ref: this.imageRef
      }, restProps));
    }
  }]);

  return IKImage;
}(ImageKitComponent);

IKImage.propTypes = COMBINED_IMAGE_PROP_TYPES;

var Props$3 = {
  path: PropTypes__default['default'].string,
  src: PropTypes__default['default'].string,
  queryParameters: PropTypes__default['default'].objectOf(PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].number]).isRequired),
  transformation: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object.isRequired),
  transformationPosition: PropTypes__default['default'].oneOf(['path', 'query'])
};

var COMBINED_IMAGE_PROP_TYPES$1 = _objectSpread2$1(_objectSpread2$1({}, Props$2), Props$3);

var propsAffectingURL$1 = ["urlEndpoint", "path", "src", "transformation", "transformationPosition", "queryParameters"];

var IKVideo = /*#__PURE__*/function (_ImageKitComponent) {
  _inherits(IKVideo, _ImageKitComponent);

  var _super = _createSuper(IKVideo);

  function IKVideo(props, context) {
    var _this;

    _classCallCheck$1(this, IKVideo);

    _this = _super.call(this, props, context);
    _this.videoRef = /*#__PURE__*/React__default['default'].createRef();

    var _getSrc = getSrc(_this.props, _this.getIKClient(), _this.getContext()),
        originalSrc = _getSrc.originalSrc;

    _this.state = {
      currentUrl: originalSrc,
      contextOptions: {}
    };
    return _this;
  }

  _createClass$1(IKVideo, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({
        contextOptions: this.getContext()
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this2 = this;

      var contextOptions = this.getContext();

      if (areObjectsDifferent(prevProps, this.props, propsAffectingURL$1) || areObjectsDifferent(prevState.contextOptions, contextOptions, propsAffectingURL$1)) {
        var _getSrc2 = getSrc(this.props, this.getIKClient(), this.getContext()),
            originalSrc = _getSrc2.originalSrc;

        this.setState({
          currentUrl: originalSrc
        }, function () {
          _this2.setState({
            contextOptions: _this2.getContext()
          });
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var currentUrl = this.state.currentUrl;

      var _this$props = this.props,
          urlEndpoint = _this$props.urlEndpoint,
          path = _this$props.path,
          src = _this$props.src,
          transformation = _this$props.transformation,
          transformationPosition = _this$props.transformationPosition,
          queryParameters = _this$props.queryParameters,
          restProps = _objectWithoutProperties(_this$props, ["urlEndpoint", "path", "src", "transformation", "transformationPosition", "queryParameters"]);

      return /*#__PURE__*/React__default['default'].createElement("video", _extends({}, restProps, {
        ref: this.videoRef
      }), /*#__PURE__*/React__default['default'].createElement("source", {
        src: currentUrl,
        type: "video/mp4"
      }));
    }
  }]);

  return IKVideo;
}(ImageKitComponent);

IKVideo.propTypes = COMBINED_IMAGE_PROP_TYPES$1;

var PROP_TYPES = _objectSpread2$1(_objectSpread2$1({}, Props$2), Props$1);

var IKUpload = /*#__PURE__*/function (_ImageKitComponent) {
  _inherits(IKUpload, _ImageKitComponent);

  var _super = _createSuper(IKUpload);

  function IKUpload() {
    var _temp, _this;

    _classCallCheck$1(this, IKUpload);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _possibleConstructorReturn(_this, (_temp = _this = _super.call.apply(_super, [this].concat(args)), _this.state = {}, _temp));
  }

  _createClass$1(IKUpload, [{
    key: "abort",
    value: function abort() {
      if (this.state.xhr) {
        this.state.xhr.abort();
      }
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(e) {
      var _e$target$files,
          _this2 = this;

      var contextOptions = this.getContext();
      var _this$props = this.props,
          fileName = _this$props.fileName,
          useUniqueFileName = _this$props.useUniqueFileName,
          tags = _this$props.tags,
          folder = _this$props.folder,
          isPrivateFile = _this$props.isPrivateFile,
          customCoordinates = _this$props.customCoordinates,
          responseFields = _this$props.responseFields,
          extensions = _this$props.extensions,
          webhookUrl = _this$props.webhookUrl,
          overwriteFile = _this$props.overwriteFile,
          overwriteAITags = _this$props.overwriteAITags,
          overwriteTags = _this$props.overwriteTags,
          overwriteCustomMetadata = _this$props.overwriteCustomMetadata,
          customMetadata = _this$props.customMetadata,
          onError = _this$props.onError,
          onSuccess = _this$props.onSuccess;
      var publicKey = this.props.publicKey || contextOptions.publicKey;
      var authenticationEndpoint = this.props.authenticationEndpoint || contextOptions.authenticationEndpoint;
      var urlEndpoint = this.props.urlEndpoint || contextOptions.urlEndpoint;

      if (!publicKey || publicKey.trim() === "") {
        if (onError && typeof onError === "function") {
          onError({
            message: "Missing publicKey"
          });
        }

        return;
      }

      if (!authenticationEndpoint || authenticationEndpoint.trim() === "") {
        if (onError && typeof onError === "function") {
          onError({
            message: "Missing authenticationEndpoint"
          });
        }

        return;
      }

      if (!urlEndpoint || urlEndpoint.trim() === "") {
        if (onError && typeof onError === "function") {
          onError({
            message: "Missing urlEndpoint"
          });
        }

        return;
      }

      var ikClient = this.getIKClient();
      var file = (_e$target$files = e.target.files) === null || _e$target$files === void 0 ? void 0 : _e$target$files[0];

      if (!file) {
        return;
      }

      if (this.props.validateFile && !this.props.validateFile(file)) {
        return;
      }

      if (this.props.onUploadStart && typeof this.props.onUploadStart === "function") {
        this.props.onUploadStart(e);
      }

      var xhr = new XMLHttpRequest();

      var progressCb = function progressCb(e) {
        if (_this2.props.onUploadProgress && typeof _this2.props.onUploadProgress === 'function') {
          _this2.props.onUploadProgress(e);
        }
      };

      xhr.upload.addEventListener('progress', progressCb);
      var params = {
        file: file,
        fileName: fileName || file.name,
        useUniqueFileName: useUniqueFileName,
        tags: tags,
        folder: folder,
        isPrivateFile: isPrivateFile,
        customCoordinates: customCoordinates,
        responseFields: responseFields,
        extensions: extensions,
        webhookUrl: webhookUrl,
        overwriteFile: overwriteFile,
        overwriteAITags: overwriteAITags,
        overwriteTags: overwriteTags,
        overwriteCustomMetadata: overwriteCustomMetadata,
        customMetadata: customMetadata,
        xhr: xhr
      };
      ikClient.upload(params, function (err, result) {
        if (err) {
          if (onError && typeof onError === "function") {
            onError(err);
          }
        } else {
          if (onSuccess && typeof onSuccess === "function") {
            onSuccess(result);
          }
        }

        xhr.upload.removeEventListener('progress', progressCb);
      }, {
        publicKey: publicKey,
        authenticationEndpoint: authenticationEndpoint
      });
      this.setState({
        xhr: xhr
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props2 = this.props,
          publicKey = _this$props2.publicKey,
          urlEndpoint = _this$props2.urlEndpoint,
          authenticationEndpoint = _this$props2.authenticationEndpoint,
          fileName = _this$props2.fileName,
          useUniqueFileName = _this$props2.useUniqueFileName,
          tags = _this$props2.tags,
          folder = _this$props2.folder,
          isPrivateFile = _this$props2.isPrivateFile,
          customCoordinates = _this$props2.customCoordinates,
          responseFields = _this$props2.responseFields,
          onError = _this$props2.onError,
          onSuccess = _this$props2.onSuccess,
          onUploadStart = _this$props2.onUploadStart,
          onUploadProgress = _this$props2.onUploadProgress,
          inputRef = _this$props2.inputRef,
          validateFile = _this$props2.validateFile,
          restProps = _objectWithoutProperties(_this$props2, ["publicKey", "urlEndpoint", "authenticationEndpoint", "fileName", "useUniqueFileName", "tags", "folder", "isPrivateFile", "customCoordinates", "responseFields", "onError", "onSuccess", "onUploadStart", "onUploadProgress", "inputRef", "validateFile"]);

      return /*#__PURE__*/React__default['default'].createElement("input", _extends({}, restProps, {
        ref: inputRef,
        type: "file",
        onChange: function onChange(e) {
          if (_this3.props.onChange && typeof _this3.props.onChange === "function") {
            _this3.props.onChange(e);
          }

          _this3.uploadFile(e);
        }
      }));
    }
  }]);

  return IKUpload;
}(ImageKitComponent);

IKUpload.propTypes = PROP_TYPES;
IKUpload.defaultProps = {
  useUniqueFileName: true,
  isPrivateFile: false,
  customCoordinates: "",
  tags: [],
  folder: "/",
  responseFields: []
};

exports.IKContext = IKContext;
exports.IKCore = ImageKit;
exports.IKImage = IKImage;
exports.IKUpload = IKUpload;
exports.IKVideo = IKVideo;
